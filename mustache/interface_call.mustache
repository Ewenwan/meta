public:
template <typename... Args>
bool interface_call(const std::string& func_name, const Args&... data)
{
    auto func_index_opt = get_idx_for_interface(func_name);
    if(!func_index_opt)
    {
        return false;
    }
    auto cur_func_index = func_index_opt.value();
    switch(cur_func_index)
    {
        {{#func_methods}}
        case {{func_index}}:
        {
            {{#func_args}}
            {{{arg_type}}} {{arg_name}};
            {{/func_args}}
            bool decode_result = decode_multi(json_arg{{#func_args}}, {{arg_name}}{{/func_args}});
            if(decode_result)
            {
                {{func_name}}({{#func_args}}{{arg_name}}{{^last_idx}}, {{/last_idx}}{{/func_args}});
            }
            else
            {
                the_logger.warn("fail to decode args {} for rpc {{func_name}} index {}", args,  cur_func_index);
            }
            return decode_result;
        }
        {{/func_methods}}
        default:
            the_logger.warn("cant find rpc_name with rpc_index {} args {}", rpc_index, args);
            return false;
    }
	
}

static std::optional<std::uint16_t> get_idx_for_interface(const std::string& func_name)
{
    auto& all_func_indexes = interface_indexes();
    auto cur_iter = all_func_indexes.find(func_name);
    if(cur_iter == all_func_indexes.end())
    {
        return std::nullopt;
    }
    else
    {
        return cur_iter->second;
    }
}
private:
